Target feature flags: arm-64-osx-arm_dot_prod-arm_fp16-jit-user_context
Creating initial loop nests...
Injecting realization of { consumer_default }
Inlining producer_default
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Asserting that all split factors are positive...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Bounding constant extent loops...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Writing symbolic complexity pass...
Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)consumer_default.buffer) != (uint64)0, halide_error_buffer_argument_is_null("consumer_default"))
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 assert(consumer_default.type == (uint32)73730, halide_error_bad_type("Output buffer consumer_default", consumer_default.type, (uint32)73730))
 assert(consumer_default.dimensions == 2, halide_error_bad_dimensions("Output buffer consumer_default", consumer_default.dimensions, 2))
 assert(0 <= consumer_default.extent.0, halide_error_buffer_extents_negative("Output buffer consumer_default", 0, consumer_default.extent.0))
 assert(0 <= consumer_default.extent.1, halide_error_buffer_extents_negative("Output buffer consumer_default", 1, consumer_default.extent.1))
 assert(consumer_default.stride.0 == 1, halide_error_constraint_violated("consumer_default.stride.0", consumer_default.stride.0, "1", 1))
 let consumer_default.total_extent.1 = int64(consumer_default.extent.1)*int64(consumer_default.extent.0)
 assert((uint64)abs(int64(consumer_default.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)), (uint64)2147483647))
 assert(consumer_default.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("consumer_default", consumer_default.total_extent.1, (int64)2147483647))
 assert(!consumer_default.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer consumer_default"))
 assert(consumer_default != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer consumer_default"))
 produce consumer_default {
  let t3 = 0 - (consumer_default.min.1*consumer_default.stride.1)
  for (consumer_default.s0.y.rebased, 0, consumer_default.extent.1) {
   let t4 = consumer_default.min.1 + consumer_default.s0.y.rebased
   for (consumer_default.s0.x.rebased, 0, consumer_default.extent.0) {
    let t1 = consumer_default.min.0 + consumer_default.s0.x.rebased
    consumer_default[((consumer_default.stride.1*t4) + t3) + consumer_default.s0.x.rebased] = ((float32)sin_f32(float32(((t1 + 1)*(t4 + 1)))) + ((float32)sin_f32(float32(((t1 + 1)*t4))) + ((float32)sin_f32(float32((t1*t4))) + (float32)sin_f32(float32(((t4 + 1)*t1))))))*0.250000f
   }
  }
 }
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Finished main lowering passes...
Public arg: __user_context
Type: (void const *)
Public arg: consumer_default
Type: float32
lowered stmt:
assert(reinterpret<uint64>((struct halide_buffer_t *)consumer_default.buffer) != (uint64)0, halide_error_buffer_argument_is_null("consumer_default"))
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 assert(consumer_default.type == (uint32)73730, halide_error_bad_type("Output buffer consumer_default", consumer_default.type, (uint32)73730))
 assert(consumer_default.dimensions == 2, halide_error_bad_dimensions("Output buffer consumer_default", consumer_default.dimensions, 2))
 assert(0 <= consumer_default.extent.0, halide_error_buffer_extents_negative("Output buffer consumer_default", 0, consumer_default.extent.0))
 assert(0 <= consumer_default.extent.1, halide_error_buffer_extents_negative("Output buffer consumer_default", 1, consumer_default.extent.1))
 assert(consumer_default.stride.0 == 1, halide_error_constraint_violated("consumer_default.stride.0", consumer_default.stride.0, "1", 1))
 let consumer_default.total_extent.1 = int64(consumer_default.extent.1)*int64(consumer_default.extent.0)
 assert((uint64)abs(int64(consumer_default.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)), (uint64)2147483647))
 assert(consumer_default.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("consumer_default", consumer_default.total_extent.1, (int64)2147483647))
 assert(!consumer_default.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer consumer_default"))
 assert(consumer_default != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer consumer_default"))
 produce consumer_default {
  let t3 = 0 - (consumer_default.min.1*consumer_default.stride.1)
  for (consumer_default.s0.y.rebased, 0, consumer_default.extent.1) {
   let t4 = consumer_default.min.1 + consumer_default.s0.y.rebased
   for (consumer_default.s0.x.rebased, 0, consumer_default.extent.0) {
    let t1 = consumer_default.min.0 + consumer_default.s0.x.rebased
    consumer_default[((consumer_default.stride.1*t4) + t3) + consumer_default.s0.x.rebased] = ((float32)sin_f32(float32(((t1 + 1)*(t4 + 1)))) + ((float32)sin_f32(float32(((t1 + 1)*t4))) + ((float32)sin_f32(float32((t1*t4))) + (float32)sin_f32(float32(((t4 + 1)*t1))))))*0.250000f
   }
  }
 }
}

Running SCA
smoketest stmt:
assert(reinterpret<uint64>((struct halide_buffer_t *)consumer_default.buffer) != (uint64)0, halide_error_buffer_argument_is_null("consumer_default"))
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 assert(consumer_default.type == (uint32)73730, halide_error_bad_type("Output buffer consumer_default", consumer_default.type, (uint32)73730))
 assert(consumer_default.dimensions == 2, halide_error_bad_dimensions("Output buffer consumer_default", consumer_default.dimensions, 2))
 assert(0 <= consumer_default.extent.0, halide_error_buffer_extents_negative("Output buffer consumer_default", 0, consumer_default.extent.0))
 assert(0 <= consumer_default.extent.1, halide_error_buffer_extents_negative("Output buffer consumer_default", 1, consumer_default.extent.1))
 assert(consumer_default.stride.0 == 1, halide_error_constraint_violated("consumer_default.stride.0", consumer_default.stride.0, "1", 1))
 let consumer_default.total_extent.1 = int64(consumer_default.extent.1)*int64(consumer_default.extent.0)
 assert((uint64)abs(int64(consumer_default.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("consumer_default", (uint64)abs(int64(consumer_default.extent.1)*int64(consumer_default.stride.1)), (uint64)2147483647))
 assert(consumer_default.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("consumer_default", consumer_default.total_extent.1, (int64)2147483647))
 assert(!consumer_default.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer consumer_default"))
 assert(consumer_default != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer consumer_default"))
 allocate consumer_default_metrics_array[int32]
 produce consumer_default_storing {
  consumer_default_metrics_array[0] = 0
 }
}

Target triple of initial module: arm64-apple-macosx11.0.0
Generating llvm bitcode...
Generating llvm bitcode prolog for function consumer_default...
Generating llvm bitcode for function consumer_default...
JIT compiling shared runtime for arm-64-osx-arm_dot_prod-arm_fp16-jit-user_context
JIT compiling consumer_default for arm-64-osx-arm_dot_prod-arm_fp16-jit-user_context
Target feature flags: arm-64-osx-arm_dot_prod-arm_fp16-no_asserts
Creating initial loop nests...
Injecting realization of { consumer_default }
Inlining producer_default
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Clamping unsafe data-dependent accesses
Performing computation bounds inference...
Asserting that all split factors are positive...
Removing extern loops...
Performing sliding window optimization...
Uniquifying variable names...
Simplifying...
Simplifying correlated differences...
Performing allocation bounds inference...
Adding checks for images
Removing code that depends on undef values...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Discarding safe promises...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Bounding small realizations...
Performing storage flattening...
Adding atomic mutex allocation...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Simplifying...
Reduce prefetch dimension...
Simplifying correlated differences...
Bounding constant extent loops...
Unrolling...
Vectorizing...
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Staging strided loads...
Trimming loops to the region over which they do something...
Rebasing loops to zero...
Hoisting loop invariant if statements...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Simplifying...
Lowering unsafe promises...
Flattening nested ramps...
Removing dead allocations and moving loop invariant code...
Finding intrinsics...
Hoisting prefetches...
Stripping asserts...
Writing symbolic complexity pass...
Lowering after final simplification:
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 produce consumer_default {
  let t8 = 0 - (consumer_default.min.1*consumer_default.stride.1)
  for (consumer_default.s0.y.rebased, 0, consumer_default.extent.1) {
   let t9 = consumer_default.min.1 + consumer_default.s0.y.rebased
   for (consumer_default.s0.x.rebased, 0, consumer_default.extent.0) {
    let t6 = consumer_default.min.0 + consumer_default.s0.x.rebased
    consumer_default[((consumer_default.stride.1*t9) + t8) + consumer_default.s0.x.rebased] = ((float32)sin_f32(float32(((t6 + 1)*(t9 + 1)))) + ((float32)sin_f32(float32(((t6 + 1)*t9))) + ((float32)sin_f32(float32((t6*t9))) + (float32)sin_f32(float32(((t9 + 1)*t6))))))*0.250000f
   }
  }
 }
}


Skipping Hexagon offload...
Skipping GPU offload...
Lowering Parallel Tasks...
Finished main lowering passes...
Public arg: consumer_default
Type: float32
lowered stmt:
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 produce consumer_default {
  let t8 = 0 - (consumer_default.min.1*consumer_default.stride.1)
  for (consumer_default.s0.y.rebased, 0, consumer_default.extent.1) {
   let t9 = consumer_default.min.1 + consumer_default.s0.y.rebased
   for (consumer_default.s0.x.rebased, 0, consumer_default.extent.0) {
    let t6 = consumer_default.min.0 + consumer_default.s0.x.rebased
    consumer_default[((consumer_default.stride.1*t9) + t8) + consumer_default.s0.x.rebased] = ((float32)sin_f32(float32(((t6 + 1)*(t9 + 1)))) + ((float32)sin_f32(float32(((t6 + 1)*t9))) + ((float32)sin_f32(float32((t6*t9))) + (float32)sin_f32(float32(((t9 + 1)*t6))))))*0.250000f
   }
  }
 }
}

Running SCA
smoketest stmt:
let consumer_default = (void *)_halide_buffer_get_host((struct halide_buffer_t *)consumer_default.buffer)
let consumer_default.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 0)
let consumer_default.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)consumer_default.buffer, 1)
let consumer_default.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)consumer_default.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)consumer_default.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)consumer_default.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 2, 32, 2, (struct halide_dimension_t *)make_struct(consumer_default.min.0, consumer_default.extent.0, 1, 0, consumer_default.min.1, consumer_default.extent.1, consumer_default.extent.0, 0), (uint64)0)
}
if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)consumer_default.buffer)) {
 allocate consumer_default_metrics_array[int32]
 produce consumer_default_storing {
  consumer_default_metrics_array[0] = 0
 }
}

Target triple of initial module: arm64-apple-macosx11.0.0
Generating llvm bitcode...
Generating llvm bitcode prolog for function consumer...
Generating llvm bitcode for function consumer...
Module.compile(): object sca_analysis.o
emit_file.Compiling to native code...
Target machine is Position Independent!
Module.compile(): c_header sca_analysis.h
dir_rmdir: /tmp/KEzSxP

Pseudo-code for the schedule:
Injecting realization of { consumer_default }
Inlining producer_default
produce consumer_default:
  for y:
    for x:
      consumer_default(...) = ...

Success!
